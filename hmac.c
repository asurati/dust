/*
 * Copyright (c) 2018 Amol Surati
 *
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

#include <assert.h>
#include <stdio.h>
#include <string.h>

#include <sys/hmac.h>

static const uint8_t opad[SHA256_BLOCK_LEN] = {
	0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
	0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
	0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
	0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
	0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
	0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
	0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,
	0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c
};

static const uint8_t ipad[SHA256_BLOCK_LEN] = {
	0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
	0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
	0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
	0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
	0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
	0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
	0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
	0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36
};

void hmac_sha256_init(struct hmac_sha256_ctx *ctx, const void *key, int klen)
{
	int i;
	uint8_t blk[SHA256_BLOCK_LEN];
	uint8_t dgst[SHA256_DIGEST_LEN];
	struct hmac_sha256 *c;
	struct sha256_ctx *hc;

	c = (struct hmac_sha256 *)ctx;

	assert(c != NULL);
	assert(sizeof(*ctx) == sizeof(*c));

	hc = &c->sha256;

	memset(c->k, 0, sizeof(c->k));
	if (klen > SHA256_BLOCK_LEN) {
		sha256_init(hc);
		sha256_update(hc, key, klen);
		sha256_final(hc, dgst);
		memcpy(c->k, dgst, sizeof(dgst));
	} else {
		memcpy(c->k, key, klen);
	}

	memcpy(blk, c->k, SHA256_BLOCK_LEN);
	for (i = 0; i < SHA256_BLOCK_LEN; ++i)
		blk[i] ^= ipad[i];

	sha256_init(hc);
	sha256_update(hc, blk, sizeof(blk));
}

void hmac_sha256_update(struct hmac_sha256_ctx *ctx, const void *bytes,
			int len)
{
	struct hmac_sha256 *c = (struct hmac_sha256 *)ctx;

	assert(c);
	sha256_update(&c->sha256, bytes, len);
}

void hmac_sha256_final(struct hmac_sha256_ctx *ctx, uint8_t *bytes)
{
	struct hmac_sha256 *c = (struct hmac_sha256 *)ctx;
	int i;
	struct sha256_ctx *hc;
	uint8_t dgst[SHA256_DIGEST_LEN];
	uint8_t blk[SHA256_BLOCK_LEN];

	hc = &c->sha256;
	sha256_final(hc, dgst);

	memcpy(blk, c->k, SHA256_BLOCK_LEN);
	for (i = 0; i < SHA256_BLOCK_LEN; ++i)
		blk[i] ^= opad[i];

	sha256_init(hc);
	sha256_update(hc, blk, sizeof(blk));
	sha256_update(hc, dgst, sizeof(dgst));
	sha256_final(hc, bytes);

	/* TODO secure. */
	memset(c, -1, sizeof(*c));
}
